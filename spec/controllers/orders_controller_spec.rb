require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.
#
# Also compared to earlier versions of this generator, there are no longer any
# expectations of assigns and templates rendered. These features have been
# removed from Rails core in Rails 5, but can be added back in via the
# `rails-controller-testing` gem.

RSpec.describe OrdersController, type: :controller do
  # This should return the minimal set of attributes required to create a valid
  # Order. As you add validations to Order, be sure to
  # adjust the attributes here as well.
  let(:valid_attributes) {
    skip("Add a hash of attributes valid for your model")
  }

  let(:invalid_attributes) {
    skip("Add a hash of attributes invalid for your model")
  }

  let!(:cashier) { create(:cashier, email: Faker::Internet.email) }
  
  # This should return the minimal set of values that should be in the session
  # in order to pass any filters (e.g. authentication) defined in
  # OrdersController. Be sure to keep this updated too.
  let(:valid_session) { {current_user: cashier.user} }

  # before do
  #   allow(request.env['warder']).to receive(:authenticate!).and_return(current_user)
  #   allow(controller).to receive(:current_user).and_return(current_user)
  # end
  
  describe "GET #index" do
    context "when cashier is not logged in" do
      it "should return unauthorized" do
        get :index
        expect(response).to_not be_success
      end
    end

    context "when cashier is logged in" do
      login_cashier
      
      it "returns a success response" do
        get :index
        expect(response).to be_success
      end
    end
    
    context "when manager is logged in" do
      login_manager

      let!(:order1) { create(:order, created_at: Date.today) }
      let!(:order2) { create(:order, created_at: 1.day.ago) }
    
      context "when filter through date" do
        it "should return filtered orders" do
          get :index, order_date: Date.today
          expect(assigns(:orders)).to eq([order1])
        end
      end

      context "when not filter through date" do
        it "should return all orders" do
          get :index
          expect(assigns(:orders)).to eq([order1, order2])
        end
      end
    end

    context "when baker is logged in" do
      login_baker
      
      let!(:completed_order) { create(:order, is_completed: true) }
      let!(:incompleted_order) { create(:order, is_completed: false) }

      it "should see only incomplete orders" do
        get :index
        expect(assigns(:orders)).to eq([incompleted_order])
      end
    end

    context "when cashier is logged in" do
      login_cashier
      
      let!(:completed_order) { create(:order, is_completed: true) }
      let!(:incompleted_order) { create(:order, is_completed: false) }
      let!(:current_order) { create(:order) }
      let!(:previous_order) { create(:order, created_at: 1.day.ago) }
      
      it "should see only incomplete orders" do
        get :index
        expect(assigns(:orders)).to eq([completed_order, incompleted_order, current_order, previous_order])
      end
    end
    
  end

  describe "GET #show" do
    let!(:order) { create(:order) }

    context "when user is logged in" do
      login_cashier

      it "returns a success response" do
        get :show, {:id => order.to_param}
        expect(response).to be_success
      end
    end

    context "when user is not logged in" do
      it "returns unsuccess response" do
        get :show, {:id => order.to_param}
        expect(response).to_not be_success
      end
    end
  end

  describe "GET #new" do
    context "when user is logged in" do
      login_cashier
      
      it "returns a success response" do
        get :new, {}, valid_session
        expect(response).to be_success
      end
    end

    context "when user is not logged in" do
      it "returns unsuccess response" do
        get :new, {}, valid_session
        expect(response).to_not be_success
      end
    end
    
  end

  describe "GET #edit" do
    let!(:order) { create(:order) }
    
    context "when user is logged in" do
      login_cashier
      
      it "returns a success response" do
        get :edit, {:id => order.to_param}, valid_session
        expect(response).to be_success
      end
    end

    context "when user is not logged in" do
      login_cashier
      
      it "returns unsuccess response" do
        get :edit, {:id => order.to_param}, valid_session
        expect(response).to be_success
      end
    end
  end

  describe "POST #create" do
    login_cashier
    
    context "with valid params" do
      it "creates a new Order" do
        expect {
          post :create, {:order => FactoryGirl.build(:order).attributes}
        }.to change(Order, :count).by(1)
      end

      it "redirects to the created order" do
        post :create, {:order => FactoryGirl.build(:order).attributes}
        expect(response).to redirect_to(Order.last)
      end
    end

    context "with invalid params" do
      it "returns a success response (i.e. to display the 'new' template)" do
        post :create, {:order => FactoryGirl.build(:order).attributes.merge(pizza_type_id: nil)}
        expect(response).to render_template("new")
      end
    end
  end

  describe "PUT #update" do
    let(:pizza_type1) { create(:pizza_type, name: "abc") }
    let!(:order) { create(:order) }

    login_cashier
    
    context "with valid params" do
      let(:new_attributes) {
        {pizza_type_id: pizza_type1}
      }

      it "updates the requested order" do
        put :update, {:id => order.to_param, :order => new_attributes}
        order.reload
        expect(assigns(:order).pizza_type).to eq(pizza_type1)
      end
    end

    context "with invalid params" do
      let(:invalid_attributes) {
        {pizza_type_id: nil}
      }
      
      it "returns a success response (i.e. to display the 'edit' template)" do
        put :update, {:id => order.to_param, :order => invalid_attributes}
        expect(response).to render_template("edit")
      end
    end
  end

  describe "DELETE #destroy" do
    let!(:order) { create(:order) }

    context "when user is logged in" do
      login_cashier
      
      it "destroys the requested order" do
        expect {
          delete :destroy, {:id => order.to_param}, valid_session
        }.to change(Order, :count).by(-1)
      end
    end

    context "when is not logged in" do
      it "should not destroys the requested order" do
        expect {
          delete :destroy, {:id => order.to_param}, valid_session
        }.to change(Order, :count).by(0)
      end
    end
  end

end
